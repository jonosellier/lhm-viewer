import{w as d}from"./entry.BuoIe5d7.js";import{K as S}from"./scheduler.DBwb5MXA.js";const g=d(b());function b(){return JSON.parse(localStorage.getItem("prefs")??'{"sensorColor": {}, "sensorName": {}}')}g.subscribe(c=>{localStorage.setItem("prefs",JSON.stringify(c))});function y(c,t,o){t/=100,o/=100;const r=(1-Math.abs(2*o-1))*t,n=r*(1-Math.abs(c/60%2-1)),i=o-r/2;let a=0,e=0,s=0;return 0<=c&&c<60?(a=r,e=n,s=0):60<=c&&c<120?(a=n,e=r,s=0):120<=c&&c<180?(a=0,e=r,s=n):180<=c&&c<240?(a=0,e=n,s=r):240<=c&&c<300?(a=n,e=0,s=r):300<=c&&c<360&&(a=r,e=0,s=n),a=Math.round((a+i)*255),e=Math.round((e+i)*255),s=Math.round((s+i)*255),`#${a.toString(16).padStart(2,"0")}${e.toString(16).padStart(2,"0")}${s.toString(16).padStart(2,"0")}`}class m{_pathMap=new Map;_chartType=new Map;charts=[];xAxis=[];subsets=[];name;selectedSubset=-1;show=[];static metricTypes=["control","voltage","temperature","fan","load","power","clock","factor","smalldata","data","level","throughput"];static pathMatcher=new RegExp(`/(.+)/(${m.metricTypes.join("|")})/(.+)`);getChartType(t){return this._chartType.get(t)}findByPath(t){return this._pathMap.get(t)}constructor(t,o){if(this.name=o??new Date().toISOString(),!t)return;const{hwPaths:r,sensors:n,dataRows:i}=this.readCsvData(t),a=new Set;r.forEach((h,p)=>{this._pathMap.set(h,p);const[l,f,u]=h.split("/");a.add(l),m.metricTypes.includes(f)?this._chartType.set(h,f):console.warn("[MultiChartData]: Unknown type",f,"in",h)});const e=Array.from(a).sort();let s=50;i.forEach(h=>{const[p,...l]=h.split(",");this.xAxis.push(new Date(p)),l.forEach((f,u)=>{if(!this.charts[u]){const w=e.indexOf(r[u].split("/")[0])/e.length*360;s=s>50?s/1.5:s*1.7,this.charts[u]={label:n[u],path:r[u],values:[],color:y(w,100,s)}}this.charts[u].values.push(+f)})}),this.subsets=this.detectDataSubsets(this.xAxis),this.charts.length<10&&(this.show=this.charts.map((h,p)=>p))}toCsv(t){t?.sensorsToKeep&&console.log("Trimming sensors to",t.sensorsToKeep);const o=t?.sensorsToKeep?this.charts.filter((e,s)=>t.sensorsToKeep?.includes(s)):this.charts;let r=this.xAxis;t?.subset&&(console.log("Trimming subset to",t.subset),o.forEach(e=>{e.values=e.values.slice(t.subset?.[0],t.subset?.[1])}),r=r.slice(t.subset?.[0],t.subset?.[1]));const n=`,${o.map(e=>`"/${e.path}"`).join(",")}`,i=`,${o.map(e=>`"${e.label}"`).join(",")}`,a=r.map((e,s)=>[e.toISOString()].concat(o.map(h=>h.values[s].toFixed(h.values[s]>10?0:2))).join(","));return[n,i,...a].join(`
`)}readCsvData(t){const[o,r,...n]=t.split(/\r?\n/).filter(s=>!!s).map(s=>s.replace(/"/g,"")),[i,...a]=r.split(",").map(s=>s.replace(/"/g,""));return{hwPaths:this.parseHwPaths(o),sensors:a,dataRows:n}}parseHwPaths(t){const o=S(g).sensorName,r=Object.keys(o).sort(),n=[],[i,...a]=t.split(",").map(e=>{for(let l=0;l<r.length;l++)if(e.includes(r[l]))return e.replace(r[l],o[r[l]]);const[s,h,p]=e.replace(m.pathMatcher,"$1:$2:$3").split(":");return`${s.replace(/\//g,"_").replace(/\{[A-F0-9-]+\}/,l=>(n.includes(l)||n.push(l),(n.indexOf(l)+1).toString()))}/${h}/${p}`});return a}detectDataSubsets(t){const o=t.map((a,e)=>e>0?a.valueOf()-t[e-1].valueOf():0),r=o[o.length*.9|0],n=[];let i=0;for(let a=1;a<t.length;a++)o[a]>50*r&&(n.push([i,a-1]),i=a);return n.push([i,t.length-1]),n}}const v=d(new m);v.subscribe(c=>window.my_data=c);export{m as M,v as d,g as p};
